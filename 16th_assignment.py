# -*- coding: utf-8 -*-
"""16th assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/169h65Ho4vQUTTjlQlPU0GLXN5CtJNt0f
"""

#first solution
from collections import defaultdict

def find_nearest_elements(array):
    freq = defaultdict(int)
    first_occurrence = {}
    n = len(array)
    result = [-1] * n

    # Step 1: Calculate frequency of each element
    for i in array:
        freq[i] += 1

    # Step 2: Store indices of first occurrence of each element
    for i in range(n-1, -1, -1):
        if array[i] not in first_occurrence:
            first_occurrence[array[i]] = i

    # Step 4: Iterate through array from right to left
    for i in range(n-1, -1, -1):
        current_freq = freq[array[i]]
        next_occurrence = first_occurrence[array[i]]

        # Step 5: Check for element with higher frequency on the right
        for j in range(i+1, next_occurrence):
            if freq[array[j]] > current_freq:
                result[i] = array[j]
                break

    return result

#second solution
def sort_stack(stack):
    temp_stack = []

    while stack:
        temp = stack.pop()

        while temp_stack and temp_stack[-1] > temp:
            stack.append(temp_stack.pop())

        temp_stack.append(temp)

    # Reversing the temporary stack to get ascending order
    while temp_stack:
        stack.append(temp_stack.pop())

    return stack

#thrid solution
def delete_middle_element(stack):
    if not stack:
        return

    size = len(stack)
    middle_index = size // 2
    delete_middle(stack, middle_index + 1)

def delete_middle(stack, k):
    # Base case
    if k == 1:
        stack.pop()
        return

    # Recursive case
    temp = stack.pop()
    delete_middle(stack, k - 1)
    stack.append(temp)

# Testing the function
stack1 = [1, 2, 3, 4, 5]
delete_middle_element(stack1)
print(stack1)

stack2 = [1, 2, 3, 4, 5, 6]
delete_middle_element(stack2)
print(stack2)

#fourth solution
from queue import Queue
from stack import Stack

def check_arrange_increasing(queue):
    stack = Stack()
    another_queue = Queue()
    expected = 1

    while not queue.empty():
        front = queue.get()

        if front == expected:
            expected += 1
        elif not stack.empty() and stack.top() == expected:
            stack.pop()
            another_queue.put(front)
            expected += 1
        else:
            stack.push(front)

    while not stack.empty():
        if stack.top() == expected:
            another_queue.put(stack.pop())
            expected += 1
        else:
            return False

    while not another_queue.empty():
        queue.put(another_queue.get())

    return True

#fifth solution


def reverse_number(num):
    num_str = str(num)
    stack = Stack()

    # Push each character onto the stack
    for char in num_str:
        stack.push(char)

    reversed_str = ""

    # Pop each character from the stack and append it to a new string
    while not stack.empty():
        reversed_str += stack.pop()

    reversed_num = int(reversed_str)
    return reversed_num

# Testing the function
num1 = 365
reversed_num1 = reverse_number(num1)
print(reversed_num1)

num2 = 6899
reversed_num2 = reverse_number(num2)
print(reversed_num2)

#sixth solution
from queue import Queue
from stack import Stack  # Assuming a Stack implementation is available

def reverse_k_elements(queue, k):
    if k <= 0 or k > queue.qsize():
        return queue  # No elements to reverse or invalid k value

    stack = Stack()

    # Step 1: Dequeue the first k elements and push them onto the stack
    for _ in range(k):
        stack.push(queue.get())

    # Step 2: Enqueue the remaining elements back into the queue
    while not queue.empty():
        queue.put(queue.get())

    # Step 3: Dequeue the elements from the stack and enqueue them back into the queue
    while not stack.empty():
        queue.put(stack.pop())

    return queue

# Testing the function
queue = Queue()
queue.put(1)
queue.put(2)
queue.put(3)
queue.put(4)
queue.put(5)

k = 3
reversed_queue = reverse_k_elements(queue, k)

# Printing the modified queue
while not reversed_queue.empty():
    print(reversed_queue.get(), end=" ")

